/* In the implementation of hash maps, the core components that determine their functionality and performance are the bucket array, hash function, hash code, and compression function. Below is an explanation of each of these components and how they work together in a hash map.

1. Bucket Array
The bucket array is the primary data structure used to store the elements (key-value pairs) in a hash map.

Definition: A bucket array is a fixed-size array where each index (bucket) corresponds to a group of elements that are mapped to it using the hash function.

How It Works:

The hash map uses a hash function to compute a bucket index for each key.
Keys that map to the same bucket are stored together (usually as a linked list or a dynamic array in the bucket).
Collision Handling:

Separate Chaining: Each bucket contains a linked list or other data structure to handle collisions (keys mapping to the same bucket).
Open Addressing: The elements are stored directly in the array, and a probing mechanism is used to find alternative slots for collisions.
Example: Suppose the bucket array has 10 slots (0-9), and keys like "cat", "dog", and "bat" map to indices 3, 3, and 7. Then:


Bucket Array:
Index: 0  1  2  [3]  4  5  6  [7]  8  9
       -  -  -  {cat, dog}  -  -  -  {bat}  -  -
2. Hash Function
The hash function is responsible for generating a hash code from a given key. It is critical for mapping keys to the bucket array.

Definition: A hash function is a deterministic function that takes a key and returns an integer (the hash code), which can be positive, negative, or unbounded.

Key Characteristics:

Deterministic: The same key must always produce the same hash code.
Uniform Distribution: It should distribute keys evenly across the bucket array to minimize collisions.
Fast Computation: The hash function should be computationally efficient for quick lookups.
Example of a Hash Function:


int hashFunction(std::string key) {
    int hash = 0;
    for (char ch : key) {
        hash = hash * 31 + ch;  // A simple polynomial rolling hash
    }
    return hash;
}
Note: The hash function does not directly map to bucket indices; it generates a hash code, which then needs further processing.

3. Hash Code
The hash code is the raw integer output generated by the hash function.

Definition: A hash code is a potentially large or unbounded integer value that uniquely represents a key. It may not fit within the range of the bucket array.

Characteristics:

The hash code is often larger than the size of the bucket array.
It is an intermediate step before determining the actual bucket index.
Example: For the string key "cat", the hash function might compute a hash code like 1276342. This hash code needs further processing to fit into the range of the bucket array.

4. Compression Function
The compression function maps the hash code to a valid bucket index within the bounds of the bucket array.

Definition: A compression function ensures that the hash code is "compressed" into a value that fits within the range [0, n-1], where n is the size of the bucket array.

How It Works:

The compression function takes the hash code and applies a modulo operation (%) with the size of the bucket array.
This ensures the bucket index is within valid bounds.
Example: Suppose the hash code is 1276342 and the bucket array size is 10. The compression function computes:


bucketIndex = hashCode % bucketArraySize
           = 1276342 % 10
           = 2
Key Formula:


bucketIndex = abs(hashCode) % bucketArraySize
(The abs function is used to handle negative hash codes.)

Workflow of a Hash Map
Hash Function: The key is passed through the hash function to compute the hash code.

Example: Key = "cat" → Hash Code = 1276342.
Compression Function: The hash code is compressed into a valid bucket index.

Example: Hash Code = 1276342 → Bucket Index = 1276342 % 10 = 2.
Bucket Array Access: The hash map uses the bucket index to locate the correct bucket.

Example: Bucket Index = 2 → Access the bucket at index 2.
Collision Handling (if necessary):

If multiple keys map to the same bucket, handle the collision using techniques like separate chaining or open addressing. */